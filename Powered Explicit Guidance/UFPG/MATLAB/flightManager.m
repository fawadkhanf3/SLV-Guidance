function [flight] = flightManager(vehicle, init, target, dt, s1guidance, upfgCycle, coastLength, events)
%flight = FLIGHTMANAGER(vehicle, init, target, dt, control, upfgCycle,
%                                                     coastLengths, events)
%Flight simulation for the entire vehicle. FlightSim3D only handles one
%stage - flightManager consecutively calls flightSim3D for each stage,
%until a target is reached (or a failure is detected). Outputs aggregated
%results from the entire flight.
%Assumption is that the first stage is controlled with either a pitch
%program or a simple gravity turn (ie. anything that is not active guidance)
%and remaining stages are collectively guided with a multistage UPFG.
%Supports variable coast phases' lengths and minor jettison events.
%
%REQUIRES
%    R          Global variable, radius of the body (m).
%
%INPUT
%    vehicle    Array of struct defining the entire vehicle.
%    init       Initial conditions struct, preferrably a launch site.
%    target     Target for UPFG (as generated by launchTargeting).
%    dt         Simulation precision (seconds).
%    control    Control struct to be used on the first stage.
%    upfgCycle  UPFG cycle length (guidance will called this often) (seconds).
%    coasts     Coast phase length. Two possibilities here:
%                a single float - a coast phase of this length will occur
%                between each powered phase (zero means no coasts at all),
%                array of floats - list of coast phase lenghts to occur
%                between consecutive powered phases; if this list is
%                shorter than needed, last value will be used repeatedly.
%               Values are in seconds.
%    events     Array of minor jettison events (can be empty). See entry in
%               flightSim3D for details.
%
%OUTPUT
%    flight     Results struct, packed into a superstructure for easy
%               extraction of data and visualization. Will contain results
%               (as returned by flightSim3D) packed into two arrays:
%                results.powered - all consecutive powered phases
%                results.coast - all coast phases (this might be empty)
%               Additionally will contain an .n field, which is an int
%               equal to length(results.powered).
%
%See also LAUNCHTARGETING, FLIGHTSIM3D.

    global R;
    n = length(vehicle);
    %Handle first stage first, as it's guided with a separate scheme and outputs different results struct.
    powered(1) = flightSim3D(vehicle, 1, init, s1guidance, events, dt);
    %Create UPFG handler
    upfg_control = struct('type', 3, 'target', target, 'major', upfgCycle);
    %If coast length was given by a single number, we will create an ad-hoc
    %array, so the rest of the code was more unified.
    if length(coastLength)==1
        coast_ = coastLength;
        for i=1:n
            coastLength(i) = coast_;
        end
    %If less coasts lengths were passed than needed (n-1 for n stages),
    %will replicate the last element enough times.
    elseif length(coastLength)<n-1
        for i=length(coastLength):n
            coastLength(i) = coastLength(length(coastLength));
        end
    end
    %Separate iterator for coast phases - if some are zero-long, their
    %structs will not be created, so they and powered stages will be uneven.
    c = 0;
    %Handle the rest of the flight in a loop
    for i=2:n
        %If then next coast period has non-zero length, handle it and
        %continue the flight. Otherwise just fly a powered phase from the
        %last one.
        if coastLength(i-1)>0
            %Iterate coast phases.
            coast_control = struct('type', 5, 'length', coastLength(i-1));
            c = c + 1;
            coast(c)   = flightSim3D(vehicle, i, resultsToInit(powered(i-1)), coast_control, events, dt);
            powered(i) = flightSim3D(vehicle, i, resultsToInit(coast(c)), upfg_control, events, dt);
        else
            powered(i) = flightSim3D(vehicle, i, resultsToInit(powered(i-1)), upfg_control, events, dt);
        end
        %If a powered stage was cut off by the guidance algorithm - do not
        %simulate any more stages.
        if powered(i).ENG>1 && i<n
            n = length(powered);
            fprintf('Used less stages than available (%d of %d).\n', i, length(vehicle));
            break;
        end
        %Support crash detection
        if powered(i).ENG<-10
            fprintf('Critical mission failure. Vehicle crashed (stage %d).\n', i);
            break;
        end
    end
    if ~exist('coast','var')
        coast = [];
    end
    %Output a struct and do some printouts
    flight = struct('powered', powered, 'coast', coast, 'n', n);
    if powered(n).ENG > 1
        fprintf('Successful insertion at T+%.1f into %.1fx%.1fkm, %.1f° orbit\n', max(flight.powered(n).Plots.t), flight.powered(n).Periapsis, flight.powered(n).Apoapsis, flight.powered(n).Orbit.INC);
        fprintf('Final conditions error: %.3d (angle), %.3d (eccentricity), %.3d (altitude)\n', planeError(flight, target), flight.powered(n).Orbit.ECC, abs( (target.radius-R)/1000 - flight.powered(n).Altitude));
    else
        fprintf('Mission failure with ENG code %d.\n', flight.powered(n).ENG);
    end